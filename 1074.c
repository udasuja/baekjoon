/*
 * 한수는 크기가 2^N × 2^N인 2차원 배열을 Z모양으로 탐색하려고 한다.
 * N > 1인 경우, 배열을 크기가 2^(N-1) × 2^(N-1)로 4등분 한 후에 재귀적으로 순서대로 방문한다.
 * 입력
 * 첫째 줄에 정수 N, r, c가 주어진다.
 *
 * 출력
 * r행 c열을 몇 번째로 방문했는지 출력한다.
 *
 * algorithm:
 * 2^N X 2^N 행렬을 2^(N-1) X 2^(N-1)로 4등분 한다. 즉 좌표평면이라고 생각한다.
 * 즉 r이 2^(n-1)을 넘어가는 값이고 c가 2^(n-1)이내의 값이라면 제 3사분면에 있다.
 * r이 2^(n-1)을 넘어가지 않고 c가 2^(n-1)을 넘어가는 값이라면 제 1사분면에 있다.
 * r과c가  2^(n-1)을 넘어가면 제 4사분명에 있다.
 * 즉 제 1사분면에 있으면 2^(n-1)*2^(n-1)이상 2^(n-1)*2^(n-1)*2미만의 값이다.
 * 제 2사분면에 있으면 2^(n-1)*2^(n-1)미만의 값이다.
 * 제 3사분면에 있으면 2^(n-1)*2^(n-1)*2이상 2^(n-1)*2^(n-1)*3미만의 값이다.
 *
 * 그리고 r과 c가 2^(n-1)보다 크면 각각 2^(n-1)에 해당하는 값을 뺀다.
 * r를 2로 나누어 몫을 구한다. 그리고 몫에 2^(n)를 곱하고 그 값을 총합에다가 더한다.
 * r를 2로 나누어 구한 나머지는 따로 저장한다. 
 * 만약 r의 나머지가 0이면 c를 1씩 줄여가면서 총합에 1, 3순으로 더한다.(c가 1이 될 때까지 반복)
 * 만약 r의 나머지가 1이면 총합에 2를 더하고 c를 1씩 줄여가면서 총합에 1,3순으로 더한다.(c가 1이 될 때까지 반복)
 */

#include <stdio.h>
#include <math.h>

int main(void)
{
	int n,r,c;
	int sum=0,row,col,square,num=0,i;
	scanf("%d %d %d",&n,&r,&c);
	square=(int)pow(2.0,(double)(n-1));
	square=square==1?0:square;
	if(r>square)
	{
		r-=square;
		sum+=(square*square*2);
	}
	if(c>square)
	{
		c-=square;
		sum+=(square*square);
	}
	sum=sum+((r%2==0)?r/2:(r/2)+2);
	printf("%d\n",sum);
	for(i=0;i<c;i++)
	{
		if(num==0)
		{
			sum+=1;
			num=1;
		}
		else
		{
			sum+=3;
			num=0;
		}
	}
	printf("%d",sum);
	
}

