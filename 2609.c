//유클리드 호제법을 이용한 코드이다.
/*ex) 24 18의 최대공약법을 구할 때 2로 나누고 그때의 몫인 12 9을 2로 나눌려고 시도한다.
하지만 9는 2로 나누지 못하니깐 2에 1를 더한 3으로 12와 9를 동시에 나눌 수 있는지 본다
나눌 수 있다면 3으로 나누고 아니라면 3에 1를 더한 4로 나누도록 시도한다.
이 경우에는 3으로 나눌 수 있으므로 3 1이 나온다.
이때 동시에 나눈 값인 2와 3을 곱한 값이 최대공약수가 된다.
*/

#include <stdio.h>

int main(void)
{
	int a, b;
	int amu=1;//이 amu라는 변수는 최대공약수가 된다.
	scanf_s("%d %d", &a, &b);
	for (int i=2; i < a&&i<b;)//a와 b가 i보다 작을 때 코드가 실행된다.
	//ex)a=3,b=2일 때 i=2가 b랑 같으므로 코드가 실행되지 않는다.
	{
		if (a% i == 0&&b%i==0)//a와b가 i로 나눠지면 a와 b를 i로 나누고 amu에 i를 곱해준다.
		{
			b /= i;//b랑 i랑 나눈 값이 b가된다.
			a /= i;
			amu *= i;
		}
		else//a와 b가 i로 동시에 나눠지지 않는다면
		{
			while ((a % i != 0 || b % i!=0) && (i<=a && i<=b))
//i가 a와 b보다 커지지 않는 선에서 i를 1씩 키워주며 a와 b를 동시에 나눌 수 있는 i값을 찾는다.
			{
				i++;
			}
			if (i > a||i>b)//i가 a와 b보다 커지면 반복을 종료한다.
			{
				break;
			}
			else//a와b가 i로 나눠지면 a와 b를 i로 나누고 amu에 i를 곱해준다.
			{
				b /= i;
				a /= i;
				amu *= i;
			}

		}
	}
	printf("%d\n", amu);
	printf("%d", amu * a * b);
	return 0;
}