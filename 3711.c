/*
 * Z 대학교 학생은 입학할 때 학번을 받게 된다. 학번은 0보다 크거나 같고, 
 * 10^6-1보다 작거나 같은 정수이다. Z 대학의 김상근 교수는 학번으로 학생들을 구분한다. 
 * 상근이는 학생들을 조금 더 쉽게 기억하기 위해서 자신이 가르치는 학생들의 학번을 m으로 나누었을 때, 
 * 나머지가 모두 다른 가장 작은 양의 정수를 찾으려고 한다.
 *
 * 입력
 * 첫째 줄에 테스트 케이스의 개수 N이 주어진다. 
 * 각 테스트 케이스의 첫째 줄에는 상근이가 가르치는 학생의 수 G가 (1 ≤ G ≤ 300) 주어진다. 
 * 다음 G개 줄에는 학생의 학번이 한 줄에 하나씩 주어진다. 학번이 같은 경우는 없다.
 *
 * 출력
 * 각 테스트 케이스마다, 학번을 m으로 나눈 나머지가 모두 다른 가장 작은 정수 m을 출력한다.
 * 예제:
 * 2 =>테스트 케이스의 개수
 * 1 =>가르치는 학생의 수 
 * 124866 =>가르치는 학생의 학번
 * 3 =>가르치는 학생의 수
 * 124866--학번
 * 111111--학번
 * 987651--학번
 * 출력:
 * 1
 * 8
 *
 * n개의 수를 어떤 같은 수로 나눴을때 서로 다른 나머지를 갖기 위해서는 나누는 수는 n+1이상이 되어야한다.
 * (나머지가 0인 경우를 제외)
 * 동적메모리 할당을 안 한 경우 compare[1000000]={0};와 같이 코딩하면 시간초과가 나오는 이유:
 * 시간 초과 문제가 발생하는 이유는 compare 배열의 크기와 초기화 방식 때문입니다. 
 * compare 배열의 크기를 매우 크게 설정한 경우(예: 1000000) 메모리 초기화 및 접근 시간이 많이 소요됩니다.
 * 그렇기에 동적메모리 할당하여 시간초과를 최대한 억제하였다.
 */
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
	int n;
	scanf("%d",&n);

	while(n--)
	{
		int s,i,num;
		int *compare;
		scanf("%d",&s);
		int *arr=(int*)malloc(sizeof(int)*s);
		for(i=0;i<s;i++)
		{
			scanf("%d",&arr[i]);
		}
		num=s;
		while(num)
		{	
			int stop=1;//stop이 1이면 모든 자연수를 num으로 나눴을 때 나머지가 중복되지 않음
			compare=(int*)calloc(num,sizeof(int));//num개의 배열 저장공간을 할당하고
							      //calloc으로 그 저장공간을 0으로 초기화
			for(i=0;i<s;i++)
			{
				int element=arr[i]%num;
				if(!compare[element])//나머지가 중복되지 않으면 조건문 실행
					compare[element]=1;//element에 해당하는 나머지가 존재한다는 의미
				else
				{
					stop=0;
					break;
				}
			}
			free(compare);//어차피 compare이라는 나머지 비교 배열은 
				      //위 반복문에서만 쓰이기에 메모리 할당 해제
			if(stop)//중복된 것이 없으면 while반복문 종료
				break;
			num++;//중복된 것이 있으면 num을 1증가시키고 다시 반복문 실행
		}
		free(arr);
		printf("%d\n",num);
		
	}
	return 0;
}
		


