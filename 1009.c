/*
10대 컴퓨터가 순서대로 데이터를 처리할때 마지막 데이터가 처리되는 컴퓨터의 번호는?
ex)5대 컴퓨터 10개의 데이터=>1번com-1번data,2번com-2번data,3번com-3번data,4번com-4번data,5번com-5번data,1번com-6번data ... 5번com-10번data
입력: 반복횟수
	 데이터의 개수 a,b이때 a는 밑이고 b는 계승이다.

풀이:
	어떤 수를 거듭제곱해서 나오는 수의 맨 뒤 자리수는 반복될 것이다. => ex)2^1=2,2^2=4,2^3=8,2^4=16,2^5=32,2^6=64와 같이 2의 거듭제곱은 2의 약수이기에
	똑같은 수가 반복되고 반복횟수는 일정하다. 결과 값의 맨 뒤 자리수가 2가 나올려면 2가 아닌 자리수가 3번 나와야한다.
	그렇기에 b가 어떤 수의 거듭제곱의 횟수라면 a를 1승부터 b승까지 거듭제곱을 하며 맨 뒤자리수 반복횟수가 b승보다 클 때는 b승 나왔을 때의 맨 뒷자리수를 반환하고
	아니면 반복회수와 b를 나누고 나머지가 발생하면 a의 1승부터 반복횟수까지 거듭제곱후에 맨 뒷자리 반환
	이때 나머지가 없으면 a의 1승의 맨 뒷자리수 반환하고 맨 뒷자리 수가 0이면 10을 출력한다.
*/

#include <stdio.h>

int main(void)
{
	int n,i;

	scanf_s("%d", &n);
	for (i = 0; i < n; i++)
	{
		int a, b,k,num1;
		int count = 1;

		scanf_s("%d %d", &a, &b);
		if ((a % 10)==0)//10으로 나눴을 때 나머지가 0이면 10번째 컴퓨터가 마지막으로 데이터를 처리할 것이다.
		{
			printf("%d\n", 10);
			continue;
		}
		num1 = a%10;//a의 맨 뒷자리를 num1에 저장한다.
		for (k = 1; k < b; k++)//a의 1승은 건너뛰므로 k는 1부터 시작한다.
		{
			num1 *= (a%10);//a의 맨 뒷자리 수만 구하여 그것을 제곱한다.
			if ((num1 % 10) == (a % 10))
			{
				num1 /= (a%10);//num1과 a의 맨 뒷자리가 같아지는 순간보다 한 단계전의 맨 뒷자리수가 num1에 저장된다.
				//그렇기에 count에 1를 더하지 않는다.
				break;
			}
			else
			{
				count += 1;
				num1 %= 10;
			}
		}
		if (k == b)//위 반복문을 계속 했을때 맨 뒷자리수의 반복횟수보다 계승이 더 클 경우
		{
			printf("%d\n", num1 % 10);
		}
		else
		{
			b %= count;//계승을 반복횟수와 나눈뒤 나머지를 b에 저장한다.
			if (b <= 0)//b가 0이라면 반복횟수의 맨 마지막 수의 맨 뒤자리를 출력한다.
				//예를 들어 2의 반복횟수가 4일 때 a=2 b=4라고 했다면 2^4인 16의 맨 뒷자리인 6을 출력한다.
			{
				printf("%d\n", num1 % 10);
			}
			else
			{
				if (b != 1)
				{
					while (b--)//반복횟수만큼 곱하고 출력한다.
					{
						num1 *= (a % 10);
						num1 %= 10;
					}
					printf("%d\n", num1 % 10);
				}
				else//b가 1이라면 a의 1승한 값을 출력하므로 a의 맨 뒷자리를 출력한다.
					printf("%d\n", a%10);
			}
		}
	}
	return 0;
}
